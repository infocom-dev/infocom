{"remainingRequest":"/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/app/src/components/RangeSlider.vue?vue&type=style&index=0&id=d2806904&scoped=true&lang=css&","dependencies":[{"path":"/app/src/components/RangeSlider.vue","mtime":1610449934880},{"path":"/app/node_modules/css-loader/dist/cjs.js","mtime":1610126726916},{"path":"/app/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1610126728456},{"path":"/app/node_modules/postcss-loader/src/index.js","mtime":1610126727680},{"path":"/app/node_modules/cache-loader/dist/cjs.js","mtime":1610126726712},{"path":"/app/node_modules/vue-loader/lib/index.js","mtime":1610126728456}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLnJhbmdlIHsKICBwYWRkaW5nOiAxcHggMDsKfQouYmFyLAouZmlsbGVkIHsKICBwb3NpdGlvbjogcmVsYXRpdmU7Cn0KLmJhciB7CiAgdHJhbnNpdGlvbjogYWxsIDAuMjVzOwogIG1hcmdpbjogMS4yZW07CiAgYm9yZGVyLXJhZGl1czogMC4zZW07CiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVzbW9rZTsKICBib3gtc2hhZG93OiAwIDAgMC4yZW07Cn0KLmZpbGxlZCB7CiAgaGVpZ2h0OiAwLjZlbTsKICBiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodHNsYXRlZ3JheTsKfQouY2lyY2xlIHsKICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgbWFyZ2luLXRvcDogLTEuM2VtOwogIG1hcmdpbi1sZWZ0OiAtMWVtOwogIHdpZHRoOiAyZW07CiAgaGVpZ2h0OiAyZW07CiAgYm9yZGVyLXJhZGl1czogNTAlOwogIGJhY2tncm91bmQtY29sb3I6ICNmZmY7CiAgYm94LXNoYWRvdzogMCAwIDAuNXJlbSAjODY4Njg2Owp9Ci5jaXJjbGU6aG92ZXIgewogIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7Cn0KLnQgewogIHRyYW5zaXRpb246IGFsbCAwLjI1czsKICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgdG9wOiAtMC41ZW07CiAgbGVmdDogLTAuNWVtOwogIGJvcmRlci1yYWRpdXM6IDUwJTsKICBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoIzAwOGNmZjM0IDUwJSwgcmdiKDAsIDEwMSwgMjUzKSk7CiAgd2lkdGg6IDNlbTsKICBoZWlnaHQ6IDNlbTsKICB0cmFuc2Zvcm06IHNjYWxlKDApOwogIHotaW5kZXg6IC0xOwp9Ci5jaXJjbGUtZHJhZyB7CiAgdHJhbnNmb3JtOiBzY2FsZSgxKTsKfQo="},{"version":3,"sources":["RangeSlider.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"RangeSlider.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"range\">\n    <div class=\"bar\">\n      <div class=\"filled\"></div>\n      <div class=\"circle\">\n        <div :class=\"{ t: true, 'circle-drag': isDraged == 1 }\"></div>\n      </div>\n      <div class=\"circle\">\n        <div :class=\"{ t: true, 'circle-drag': isDraged == 2 }\"></div>\n      </div>\n    </div>\n  </div>\n</template>\n<script type=\"text/javascript\">\nexport default {\n  props: {\n    value: {\n      type: Array,\n      default: function () {\n        return [0, 100];\n      },\n      validator: function (array) {\n        return array.length == 2 && array[0] >= 0 && array[1] <= 100;\n      },\n    },\n  },\n  data: function () {\n    return { isDraged: 0 };\n  },\n  mounted() {\n    var self = this;\n    var range = this.$el,\n      circles = range.getElementsByClassName(\"circle\"),\n      filled = range.getElementsByClassName(\"filled\")[0],\n      bar = range.getElementsByClassName(\"bar\")[0];\n    bar.onclick = function (move) {\n      var i = +(Math.abs(move.offsetX - circles[0].offsetLeft) > Math.abs(move.offsetX - circles[1].offsetLeft));\n      moveTo(i, move.clientX);\n    };\n    for (let i = 0; i < circles.length; i++) {\n      circles[i].ontouchmove = function (params) {\n        self.isDraged = i + 1;\n        moveTo(i, params.touches[0].clientX);\n      };\n      circles[i].ontouchend = function () {\n        self.isDraged = 0;\n      };\n      circles[i].onmousedown = function (e) {\n        self.isDraged = i + 1;\n        e.preventDefault();\n        range.onmousemove = function (move) {\n          moveTo(i, move.clientX);\n        };\n      };\n    }\n    range.onmouseleave = range.onmouseup = function () {\n      self.isDraged = 0;\n      range.onmousemove = null;\n    };\n    filled.style.left = circles[0].style.left = this.value[0] + \"%\";\n    filled.style.width = circles[1].style.left = this.value[1] + \"%\";\n    this.$emit(\"ready\");\n    function moveTo(index, x) {\n      var pxPerPercent = bar.offsetWidth / 100;\n      var minWidthBetweenCirclesPercents = circles[0].offsetWidth / pxPerPercent;\n      var step = (window.scrollX + x - range.offsetLeft - bar.offsetLeft) / pxPerPercent;\n      var betweenCircles = index ? step - self.value[0] : self.value[1] - step;\n      if (betweenCircles < minWidthBetweenCirclesPercents) return;\n      if (step < 0) step = 0;\n      else if (step > 100) step = 100;\n      self.value[index] = step;\n      circles[index].style.left = step + \"%\";\n      filled.style.left = circles[0].style.left;\n      filled.style.width = self.value[1] - self.value[0] + \"%\";\n      self.$emit(\"change\", { from: self.value[0], to: self.value[1] });\n    }\n  },\n};\n</script>\n\n<style scoped>\n.range {\n  padding: 1px 0;\n}\n.bar,\n.filled {\n  position: relative;\n}\n.bar {\n  transition: all 0.25s;\n  margin: 1.2em;\n  border-radius: 0.3em;\n  background-color: whitesmoke;\n  box-shadow: 0 0 0.2em;\n}\n.filled {\n  height: 0.6em;\n  background-color: lightslategray;\n}\n.circle {\n  position: absolute;\n  margin-top: -1.3em;\n  margin-left: -1em;\n  width: 2em;\n  height: 2em;\n  border-radius: 50%;\n  background-color: #fff;\n  box-shadow: 0 0 0.5rem #868686;\n}\n.circle:hover {\n  background-color: #f5f5f5;\n}\n.t {\n  transition: all 0.25s;\n  position: absolute;\n  top: -0.5em;\n  left: -0.5em;\n  border-radius: 50%;\n  background: radial-gradient(#008cff34 50%, rgb(0, 101, 253));\n  width: 3em;\n  height: 3em;\n  transform: scale(0);\n  z-index: -1;\n}\n.circle-drag {\n  transform: scale(1);\n}\n</style>"]}]}